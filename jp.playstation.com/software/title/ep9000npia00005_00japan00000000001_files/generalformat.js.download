/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}
	
	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;
	
	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];
		
			parts.push( m[1] );
		
			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}
				
				set = posProcess( selector, set );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set;

	if ( !expr ) {
		return [];
	}

	for ( var i = 0, l = Expr.order.length; i < l; i++ ) {
		var match,
			type = Expr.order[i];
		
		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			var left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( var type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				var found, item,
					filter = Expr.filter[ type ],
					left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							var pass = not ^ !!found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw "Syntax error, unrecognized expression: " + msg;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );
			
			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			// Handle if an un-quoted value was used
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}
			
			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},
	
	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},
		
		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}
			
			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			var attr = elem.getAttribute( "type" ), type = elem.type;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
		},

		radio: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
		},

		file: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
		},

		password: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
		},

		submit: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "submit" === elem.type;
		},

		image: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
		},

		reset: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "reset" === elem.type;
		},

		button: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && "button" === elem.type || name === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		},

		focus: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					if ( type === "first" ) { 
						return true; 
					}

					node = elem;

				case "last":
					while ( (node = node.nextSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					return true;

				case "nth":
					var first = match[2],
						last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}
					
					var doneName = match[0],
						parent = elem.parentNode;
	
					if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {
						var count = 0;
						
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						} 

						parent.sizcache = doneName;
					}
					
					var diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
		},
		
		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}
	
	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Utility function for retreiving the text value of an array of DOM nodes
Sizzle.getText = function( elems ) {
	var ret = "", elem;

	for ( var i = 0; elems[i]; i++ ) {
		elem = elems[i];

		// Get the text from text nodes and CDATA nodes
		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
			ret += elem.nodeValue;

		// Traverse everything else, except comment nodes
		} else if ( elem.nodeType !== 8 ) {
			ret += Sizzle.getText( elem.childNodes );
		}
	}

	return ret;
};

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}
	
		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				// See if we find a selector to speed up
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
				
				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					// Speed-up: Sizzle("TAG")
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );
					
					// Speed-up: Sizzle(".CLASS")
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}
				
				if ( context.nodeType === 9 ) {
					// Speed-up: Sizzle("body")
					// The body element only exists once, optimize finding it
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );
						
					// Speed-up: Sizzle("#ID")
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}
							
						} else {
							return makeArray( [], extra );
						}
					}
					
					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}
		
			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
		// Check to see if it's possible to do matchesSelector
		// on a disconnected node (IE 9 fails this)
		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
			pseudoWorks = false;

		try {
			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( document.documentElement, "[test!='']:sizzle" );
	
		} catch( pseudoError ) {
			pseudoWorks = true;
		}

		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try { 
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						var ret = matches.call( node, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || !disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11 ) {
							return ret;
						}
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}
	
	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem.sizcache = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;
			
			elem = elem[dir];

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem.sizcache = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833) 
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE

window.Sizzle = Sizzle;

})();

/**
 * Sony Computer Entertainment Inc.
 * 
 * @version   1.4.4
 * @lastModified 2012.5.9
 * 
 * Licensed under the MIT License
 * http://www.opensource.org/licenses/mit-license.php
 */

var SCE_APP = SCE_APP || {};
var __global = {};

SCE_APP.namespace = function (ns_string) {
	var parts = ns_string.split('.'),
		parent = this,
		i;
	for (i = 0; i < parts.length; i += 1) {
		if (typeof parent[parts[i]] === 'undefined') {
			parent[parts[i]] = {};
		}
		parent = parent[parts[i]];
	}
	return parent;
};

SCE_APP.require = function () {

};

/**
* @class Config
*/
SCE_APP.Config = (function () {
	var exports = {},
		/**
		* ※※※ Billboard自動再生時間（秒）
		*/
		AUTOPLAY_TIME = __global.AUTOPLAY_TIME || 10,
		
		/**
		* デバッグモードの真偽
		*/
		DEBUG = false
		
		/**
		* Rootパス
		*/
		, ROOT = DEBUG ? '/sce2' : '';
	
	/* ------------------------------------------------------------
	* Exports
	* ------------------------------------------------------------*/
	exports.DATA_PATH = DEBUG ? ROOT + '/common/data/' : ROOT + '';
	exports.DEBUG = DEBUG;
	exports.ROOT = ROOT;
	exports.AUTOPLAY_TIME = AUTOPLAY_TIME;
	return exports;
}());



var SCE_APP = SCE_APP || {};
SCE_APP.namespace('factory.Module')
SCE_APP.factory.Module = (function () {
	var exports = function () {};

	/**
	* 空のオブジェクトの真偽を取得
	* @param {Object} o
	* @return {Boolean}
	*/
	function isEmpty(o) {
		for (var i in o) {
			if (o.hasOwnProperty(i)) {
				return false
			}
		}
		return true
	}

	/**
	* 対象アプリにモジュールを追加
	* @param {Object} app
	* @param {String} package_
	* @param {Object} mod
	*/
	function setModule(app, package_, mod) {
		var parts = package_.split('.')
			, parent = app
			, i;

		for (i = 0; i < parts.length; ++i) {
			if (i === parts.length - 1) {
				parent[parts[i]] = mod;
				return
			}
			parent = parent[parts[i]];
		}
	}

	/**
	* モジュールの生成
	* @param package_ {String} モジュールのパッケージ・モジュール名
	* @param app {Object} パッケージを含めるアプリケーションオブジェクト
	* @param useOverride {Boolean} 上書きを許可するかの真偽 @default true
	* @param module {Object} モジュール
	*/
	exports.create = function (package_, app, useOverride, module) {
		var m
			, _module
			, _useOverride = true;
		if (!app || !app.namespace || typeof app.namespace !== 'function') {
			return;
		}

		if (typeof useOverride !== 'boolean') {
			_module = useOverride;
		} else {
			_module = module;
			_useOverride = useOverride;
		}

		m = app.namespace(package_);
		if (isEmpty(m)) {
			setModule(app, package_, _module);
		} else {
			if (_useOverride) {
				setModule(app, package_, _module);
			}
		}
	};

	return exports;
}());


var SCE_APP = SCE_APP || {};


/**
* ユーティリティ
* @namespace SCE_APP
* @class Utility
*/
SCE_APP.Utility = (function () {
	var DEBUG = SCE_APP.Config.DEBUG,
		FRAME_RATE = 16,
		_PS3 = 'ps3', _VITA = 'psv', _PSP = 'psp', _TOP = 'top',
		_SOFT = 'software', _SCE = 'scesoftware', _PSN = 'psn',
		MASTER = [{
			name: 'playstation3',
			key: _PS3
		}, {
			name: 'playstation-vita',
			key: _VITA
		}, {
			name: 'playstation-portable',
			key: _PSP
		}, {
			name: 'index',
			key: _TOP
		}, {
			name: 'software',
			key: _SOFT
		}, {
			name: 'scesoftware',
			key: _SCE
		}, {
			name: 'playstation-network',
			key: _PSN
		}]
		, ROOT = SCE_APP.Config.ROOT
		, intervals = []
		, _userAgent = (function() {
			var ua = navigator.userAgent.toLowerCase();
				
			return {
				firefox: ua.match('firefox') ? true : false,
				ie: (function(){
					var undef, v = 3, div = document.createElement('div');
					while (
						div.innerHTML = '<!--[if gt IE '+(++v)+']><i></i><![endif]-->',
						div.getElementsByTagName('i')[0]
					) {
						
					}
					if (ua.match('msie 10.')) {
						v = 10;
					}
					return v > 4 ? v : undef;
				})(),
				chrome: ua.match('Chrome') ? true : false,
				safari: (ua.match('AppleWebkit') && !ua.match('Chrome')) ? true : false,
				ps3: ua.match('playstation 3') ? true : false,
				vita: ua.match('playstation vita') ? true : false,
				opera: ua.match('Opera') ? true : false,
				smartphone: ua.match('iphone') || ua.match('android') || ua.match('ipad') ? true : false,
				version: (ua.match(/.+(?:rv|it|ra|ie)[\/: ]([\d.]+)/) || [])[1]
			};
		}())
		, listeners = {}
		, animations = []
		, query = location.hash && location.hash.replace('#', '')
		, _disableAnimate
		, _onReadyFuncs = []
		, _enterFrame = (function(){
			return window.requestAnimationFrame		||
				window.webkitRequestAnimationFrame	||
				window.mozRequestAnimationFrame		||
				window.oRequestAnimationFrame		||
				window.msRequestAnimationFrame		||
				function(callback, element){
					if (!callback) {
						return null;
					}
					return window.setInterval(callback, FRAME_RATE);
				};
		}())
		, BRIGHTCOVE_ID = '93382395002'
		, BRIGHTCOVE_KEY = 'AQ~~,AAAAAg8TOoo~,rkIIeygRFeQda4X6DGDn9XunpNt72zkK'
		, exports;
	
	if (query) {
		query = query.split('_');
	}
	_disableAnimate = {
		'fade': (_userAgent.ie <= 8 || _userAgent.ps3 || _userAgent.smartphone || _userAgent.vita)
		, 'slideto': (_userAgent.ps3 || _userAgent.smartphone || _userAgent.vita)
		, 'scrolltop': (_userAgent.ie <= 8 || _userAgent.ps3 || _userAgent.smartphone || _userAgent.vita)
		, 'sizeto': (_userAgent.ie <= 8 || _userAgent.ps3 || _userAgent.smartphone || _userAgent.vita || _userAgent.ie == 6 || _userAgent.ie == 7)
	};
	
	/* ------------------------------------------------------------
	* Private
	* ------------------------------------------------------------*/
	/**
	* 'on' + type時のqueue化
	*/
	function addListeners(target, type, func) {
		if (!listeners[type]) {
			listeners[type] = [{
				target: target,
				func: func
			}];
		} else {
			listeners[type].push({
				target: target,
				func: func
			});
		}
	}
	
	/**
	* 指定のアニメーションが登録済みかの真偽を取得
	* @param target {Object}
	* @param type {String}
	* @return {Boolean}
	*/
	function checkAnimate(target, type) {
		var i, len, animate;
		for (i = 0, len = animations.length; i < len; ++i) {
			animate = animations[i];
			if (animate && animate.target === target && animate.type === type) {
				return true;
			}
		}
		return false;
	}
	
	/**
	* 実行中のアニメーションを登録
	* @param target {Object}
	* @param type {String}
	* @param interval {Number} interval id
	*/
	function addAnimate(target, type, interval, options) {
		var i, len, animate;
		for (i = 0, len = animations.length; i < len; ++i) {
			animate = animations[i];
			if (animate && animate.target === target && animate.type === type) {
				return;
			}
		}
		animations[animations.length] = {
			target: target,
			type: type,
			options: options,
			interval: interval
		};
	}
	
	/**
	* 実行中のアニメーションから削除
	* @param target {Object}
	* @param type {String}
	*/
	function removeAnimate(target, type) {
		var i, len, animate;
		for (i = 0, len = animations.length; i < len; ++i) {
			animate = animations[i];
			if (animate && animate.target === target && animate.type === type) {
				animations[i] = null;
				animations.splice(i, 1)
			}
		}
	}
	
	/**
	* マウス座標の取得
	* @param evt {Object} EventObject
	* @return {Object} 座標オブジェクト
	*/
	function mouseCoords(evt){
		if(evt.pageX || evt.pageY){
			return {x:evt.pageX, y:evt.pageY};
		}
		return {
			x:evt.clientX + document.body.scrollLeft - document.body.clientLeft,
			y:evt.clientY + document.body.scrollTop - document.body.clientTop
		};
	}
	
	/**
	* ポジションの取得
	* @param target {Object}
	*/
	function getPosition(target) {
		var elm = target,
			left = 0,
			top = 0;
		
		while (elm.offsetParent){
			left += elm.offsetLeft;
			top += elm.offsetTop;
			elm = elm.offsetParent;
		}
		left += elm.offsetLeft || 0;
		top += elm.offsetTop || 0;
		
		return {x:left, y:top};
	}
	
	
	/* ------------------------------------------------------------
	* Exports
	* ------------------------------------------------------------*/
	exports = function() {};
	
	/**
	* ユーザーエージェントオブジェクトの取得
	* @method
	* @return {Object}
	*/
	exports.getUseragent = function () {
		return _userAgent;
	};
	
	/**
	* デバッグモードの真偽を取得
	*/
	exports.getDebug = function () {
		return DEBUG;
	};

	/**
	* サイト用brightcoveIDの取得
	*/
	exports.getBrightcoveId = function () {
		return BRIGHTCOVE_ID;
	};

	/**
	* サイト用brightcoveKEYの取得
	* @method
	* @return {String}
	*/
	exports.getBrightcoveKey = function () {
		return BRIGHTCOVE_KEY;
	};
	
	/**
	* アニメーション使用可否情報取得
	* @return {Object}
	*/
	exports.getDisableAnimate = function () {
		return _disableAnimate;
	};
	
	exports.setTestLink = function (selector) {
		var _alist = Sizzle(selector),
			_a,
			i, len = _alist.length,
			_domain;
		if (DEBUG) {
			for (i = 0; i < len; ++i) {
				_a = _alist[i];
				_domain = location.protocol + '//' + location.host;
				if (_a.href.match(_domain)) {
					_a.href = ROOT + (_a.href).replace(_domain, '');
				}
			}
		}
	};
	
	/**
	* ルートの取得
	* @return {String}
	*/
	exports.getRoot = function () {
		return ROOT;
	};
	
	/**
	* スクリプトファイル（モジュール）の読み込み
	* @param $script {String} スクリプトのパス
	* @param $callback {Function} コールバック関数
	*/
	exports.requireScript = function ($script, $callback) {
		var _script = document.createElement('script');
		_script.type = "text/javascript";
		_script.onload = function() {
			if ($callback) {
				_script.onload = null;
				_script.onreadystatechange = null;
				$callback.apply(this);
			}
		};
		_script.onreadystatechange = function() {
			if (_script.readyState === 'loaded' || _script.readyState === 'complete') {
				if ($callback) {
					_script.onload = null;
					_script.onreadystatechange = null;
					$callback.apply(this);
				}
			}
		};
		_script.src = $script;
		Sizzle('head')[0].appendChild(_script);
	};
	
	/**
	* Query文字列の取得
	* @return {String}
	*/
	exports.getQuery = function () {
		return query;
	};
	
	/**
	* フォーマットオブジェクト（マスター）
	* @property {Object}
	*/
	exports.format = {
		TOP: _TOP,
		PS3: _PS3,
		VITA: _VITA,
		PSP: _PSP,
		SOFT: _SOFT,
		SCE: _SCE,
		current: null
	};
	
	/**
	* 現在のページフォーマットを設定
	* @method
	* @param id {String} 対象ページのbodytagID
	* @param classes {String} 対象ページのbodytagのclassName
	* @return {boolean} 該当以外のフォーマット時falseを返す
	*/
	exports.setCurrentFormat = function (id, classes) {
		var i
			, len
			, _class;
		for (i = 0, len = MASTER.length; i < len; ++i) {
			_class = classes.match(MASTER[i].name);
			if (MASTER[i].name === id || _class) {
				exports.format.current = MASTER[i].key;
				return true;
			}
		}
		return false;
	};
	
	/* ------------------------------------------------------------
	* Event
	* ------------------------------------------------------------*/
	/**
	* イベント登録
	* @method
	* @param target {Object} | {Array} 対象のDOMObject
	* @param type {String} 登録するイベント
	* @param func {Function} 実行する関数
	* TODO: eventのtargetが無い場合、srcElementを代入する処理を追加する
	*/
	exports.addEventListener = function (target, type, func) {
		var _targets
			, _target
			, i
			, len
			, _bind = exports.bind;
		if (!target || !func) {
			return;
		}
		
		if (target.length) {
			_targets = target;
		} else {
			_targets = [target];
		}
		
		for (i = 0, len = _targets.length; i < len; ++i) {
			_target = _targets[i];
			if (!_target) {
				continue;
			}
			if (_target.addEventListener) {
				_target.addEventListener(type, func, false);
			} else if (_target.attachEvent) {
				_target.attachEvent('on' + type, func);
			}/* else {
				addListeners(_target, type, update || function() {});
				_target['on' + type] = function() {
					var funcs = listeners[type], i, len = funcs.length;
					if (DEBUG) {
						alert(type + ' / funcs:' + len);
					}
					for (i = 0; i < len; ++i) {
						if (funcs[i].target === _target) {
							funcs[i].apply(target);
						}
					}
				};
			} */
		}
	};
	
	/**
	* イベント登録解除
	* @method
	* @param target {Object} 対象のDOMObject
	* @param type {String} 登録するイベント
	* @param func {Function} 実行する関数
	*/
	exports.removeEventListener = function (target, type, func) {
		var _bind = exports.bind;
		if (target.removeEventListener) {
			target.removeEventListener(type, func, false);
		} else if (target.detachEvent) {
			target.detachEvent('on' + type, func);
		} else {
			target['on' + type] = null;
		}
	};
	
	/**
	* デフォルトイベントをキャンセルする
	* @param evt {Object} イベントオブジェクト
	*/
	exports.cancelEvent = function (evt) {
		if (evt.preventDefault) {
			evt.preventDefault();
			evt.stopPropagation();
		} else {
			evt.cancelBubble = true;
			evt.returnValue = false;
		}
	};
	
	/**
	* EventObjectから適切なイベントターゲットを取得する
	* @param event {Object} EventObject
	* @return {Object} targetObject
	*/
	exports.getEventTarget = function (event) {
		if (_userAgent.ps3 || !event.target && event.srcElement) {
			return event.srcElement;
		}
		return event.target;
	};
	
	/**
	* 関数のthisを固定させる
	* @param thisObject {Object} 固定させたいオブジェクト
	* @param func {Function} 固定する関数
	* @param params {Array} 固定する関数のパラメータ
	*/
	exports.bind = function (thisObject, func, params) {
		if (!params) {
			params = [];
		}
		return function() {
			var args = Array.prototype.slice.call(arguments, 0);
			func.apply(thisObject, args.concat(params));
		}
	};
	
	/* ------------------------------------------------------------
	* アニメーション
	* ------------------------------------------------------------*/
	/**
	* Windowスクロール
	* @param target {Object}
	* @param positions {Array}
	*/
	exports.scrollToPosition = function(target, positions) {
		var c = Math.floor(900 / FRAME_RATE)
			, interval
			, engine
			, mwheel
			, afterWheel
			, cache = []
			, i
			, len
			, _x
			, _y
			, _nextX
			, _nextY;
			//, _isAnime = false;
		
		if (_disableAnimate.scrolltop) {
			target.scrollTo(positions[0], positions[1]);
			return;
		}
		exports.cancelAnimation(target, 'scrolltop');
		
		_x = window.pageXOffset ? window.pageXOffset : (document.body.scrollLeft || document.documentElement.scrollLeft);
		_y = window.pageYOffset ? window.pageYOffset : (document.body.scrollTop || document.documentElement.scrollTop);
		
		for (i = 0, len = c; i < len; ++i) {
			_nextX = (_x - (_x - positions[0]) * .22);
			_nextY = (_y - (_y - positions[1]) * .22);
			
			cache[i] = {
				posX: _nextX,
				posY: _nextY,
				diffX: (_x - positions[0]),
				diffY: (_y - positions[1])
			};
			
			_x = _nextX;
			_y = _nextY;
		}
		
		i = 0;
		mwheel = _userAgent.firefox ? 'DOMMouseScroll' : 'mousewheel';
		/*
		engine = function() {
			var pos = cache[i++];
			if (pos) {
				target.scrollTo(pos.posX, pos.posY);
			}
			if (!pos || Math.abs(pos.diffX) < 1 && Math.abs(pos.diffY) < 1) {
				i = 0;
				_isAnime = false;
				clearInterval(interval);
				target.scrollTo(positions[0], positions[1]);
				removeAnimate(target, 'scrolltop');
				exports.removeEventListener(window, mwheel, afterWheel);
			} else if (_isAnime) {
				_isAnime = false;
				i = 0;
				removeAnimate(target, 'scrolltop');
				exports.removeEventListener(window, mwheel, afterWheel);
			} else {
				return _enterFrame(engine);
			}
		};
		*/
		//interval = engine();
		
		interval = setInterval(function() {
			var pos = cache[i++];
			if (pos) {
				target.scrollTo(pos.posX, pos.posY);
			}
			if (!pos || Math.abs(pos.diffX) < 1 && Math.abs(pos.diffY) < 1) {
				i = 0;
				clearInterval(interval);
				target.scrollTo(positions[0], positions[1]);
				removeAnimate(target, 'scrolltop');
				exports.removeEventListener(window, mwheel, afterWheel);
			}
		}, FRAME_RATE);
		
		afterWheel = function() {
			//if (exports.cancelAnimation(target, 'scrolltop')) {
				//_isAnime = true;
			//};
			exports.cancelAnimation(target, 'scrolltop');
			removeAnimate(target, 'scrolltop');
			exports.removeEventListener(window, mwheel, afterWheel);
			exports.removeEventListener(window, "keydow", afterWheel);
			exports.removeEventListener(document, mwheel, afterWheel);
			exports.removeEventListener(document, "keydow", afterWheel);
		};
		
		exports.addEventListener(window, mwheel, afterWheel);
		exports.addEventListener(window, "keydown", afterWheel);
		exports.addEventListener(document, mwheel, afterWheel);
		exports.addEventListener(document, "keydown", afterWheel);
		addAnimate(target, 'scrolltop', interval);
	};
	
	/**
	* 指定したIDのnodeまでスクロールする
	* @param idString {String}
	*/
	exports.scrollToId = function(idString) {
		var target = document.getElementById(idString)
			, _top;
		
		_top = exports.getOffsetTop(target);
		exports.scrollToPosition(window, [0, _top]);
	};
	exports.scrollToTarget = function(target) {
		var _top;
		if (!target) {
			return;
		}
		_top = exports.getOffsetTop(target);
		exports.scrollToPosition(window, [0, _top]);
	};

	/**
	* 指定の要素のtopを取得
	* @param target {Object} ElementObject
	* @return {Number} topの値
	*/
	exports.getOffsetTop = function(target) {
		var result = 0;
		function getParentOffsetTop(object) {

			result += object.offsetTop;
			if (object && object.offsetParent) {
				getParentOffsetTop(object.offsetParent);
			}
		}
		getParentOffsetTop(target);
		return result;
	};

	/**
	* サイズ
	* @param target {Object}
	* @param size {Object} width: {Number}, height: {Number}
	* @param update {Function}
	* @param complete {Function}
	* @param speed {Number} Speed(Option)
	*/
	exports.sizeTo = function(target, size, update, complete, speed) {
		var c
			, interval
			, offsetW
			, offsetH
			, wfactor
			, hfactor
			, anim
			, _speed
			, _w
			, _h
			, _frames = []
			, _style = exports.getComputedStyle(target);
		
		function trimSizeString(str) {
			return str.replace('px', '').replace('auto', '0');
		}

		if (!size || !size.width || !size.height) {
			size = {
				width: size.width || trimSizeString(_style.width)
				, height: size.height || trimSizeString(_style.height)
			}
		}
		
		if (_disableAnimate.sizeto || speed === 0) {
			target.style.width = size.width + 'px';
			target.style.height = size.height + 'px';
			if (complete) {
				complete.apply();
			}
			return;
		}
		
		c = Math.floor(2200 / FRAME_RATE);
		offsetW = trimSizeString(_style.width);
		offsetH = trimSizeString(_style.height);
		wfactor = (offsetW - size.width) / c;
		hfactor = (offsetH - size.height) / c;
		_speed = speed || .09;
		anim = exports.getAnimation(target, 'sizeto');
		if (anim) {
			exports.cancelAnimation(target, 'sizeto');
			target.style.width = anim.options.size.width;
			target.style.height = anim.options.size.height;
		}
		
		_w = Number(trimSizeString(_style.width));
		_h = Number(trimSizeString(_style.height));
		function calcSlide() {
			var nx = (_w - (_w - size.width) * _speed),
				ny = (_h - (_h - size.height) * _speed);
			
			_frames[_frames.length] = [nx + 'px', ny + 'px'];
			_w = nx;
			_h = ny;

			if ((Math.abs(_w - size.width) < 1 && Math.abs(_h - size.height) < 1) || c === 0) {
				return false;
			}
			return true;
		}
		while(calcSlide()) {
			--c;
		}
		c = 0;
		interval = setInterval(function() {
			target.style.width = _frames[c][0];
			target.style.height = _frames[c][1];
			++c;
			if (update) {
				update.apply();
			}
			if (c === _frames.length) {
				clearInterval(interval);
				target.style.width = size.width + 'px';
				target.style.height = size.height + 'px';
				removeAnimate(target, 'sizeto');
				if (complete) {
					complete.apply();
				}
			}
		}, FRAME_RATE);
		addAnimate(target, 'sizeto', interval, {size: size});

	}
	
	/**
	* スライド
	* @param target {Object}
	* @param positions {Array} 0: x, 1: y, 2: true ? ceil : floor
	* @param update {Function}
	* @param complete {Function}
	* @param speed {Number} Speed(Option)
	*/
	exports.slideTo = function(target, positions, update, complete, speed) {
		var c, interval
			, offsetX
			, offsetY
			, xfactor
			, yfactor
			, styles
			, anim
			, _speed
			, _round
			, _x, _y
			, _frames = [];
		
		if (_disableAnimate.slideto || speed === 0) {
			target.style.left = positions[0] + 'px';
			target.style.top = positions[1] + 'px';
			if (complete) {
				complete.apply();
			}
			return;
		}
		c = Math.floor(2200 / FRAME_RATE);
		styles = exports.getComputedStyle(target);
		offsetX = styles.left.replace('px', '');
		offsetY = styles.top.replace('px', '');
		xfactor = (offsetX - positions[0]) / c;
		yfactor = (offsetY - positions[1]) / c;
		_speed = speed || .09;
		_round = positions[2] ? Math.ceil : Math.floor;
		
		anim = exports.getAnimation(target, 'slide');
		if (anim) {
			exports.cancelAnimation(target, 'slide');
			target.style.left = anim.options.position[0];
			target.style.top = anim.options.position[1];
		}
		_x = target.style.left.replace('px', '').replace('pt', '');
		_y = target.style.top.replace('px', '').replace('pt', '');
		function calcSlide() {
			var nx = _round(_x - (_x - positions[0]) * _speed),
				ny = _round(_y - (_y - positions[1]) * _speed);
			_frames[_frames.length] = [nx + 'px', ny + 'px'];
			_x = nx;
			_y = ny;
			if ((Math.abs(_x - positions[0]) < 1.4 && Math.abs(_y - positions[1]) < 1.4) || c === 0) {
				return false;
			}
			return true;
		}
		while(calcSlide()) {
			--c;
		}
		c = 0;
		var s = target.style
			,l = _frames.length;
		interval = setInterval(function() {
			var f = _frames[c];
			s.left = f[0];
			s.top = f[1];
			++c;
			if (update) {
				update.apply();
			}
			if (c === l) {
				clearInterval(interval);
				s.left = positions[0] + 'px';
				s.top = positions[1] + 'px';
				removeAnimate(target, 'size');
				if (complete) {
					complete.apply();
				}
			}
		}, FRAME_RATE);
		addAnimate(target, 'slide', interval, {position: positions});
	};
	
	/**
	* フェードアウト
	* @method
	* @param target {Object} 対象DOMObject
	* @param duration {Number} 所要時間
	* @param callback {Function} コールバック関数
	* @param displaynone {Boolean} out完了時display: noneを設定するかの真偽
	*/
	exports.fadeOut = function(target, duration, callback, displaynone) {
		var c = Math.floor(duration / FRAME_RATE),
			op,
			interval,
			factor = 1 / c;
		
		if (displaynone === undefined) {
			displaynone = true;
		}
		if (!target || checkAnimate(target, 'fadeout') || target.style.opacity == '0') {
			return;
		}
		
		op = exports.getOpacity(target);
		if (!op) {
			op = 0;
		}
		exports.cancelAnimation(target, 'fadein');
		interval = setInterval(function() {
			op -= factor;
			exports.setOpacityTo(target, op);
			--c;
			if (c === 0) {
				clearInterval(interval);
				exports.setOpacityZero(target);
				if (displaynone) {
					target.style.display = 'none';
				}
				removeAnimate(target, 'fadeout');
				if (callback) {
					callback.apply();
					delete callback;
				}
			}
		}, FRAME_RATE);
		addAnimate(target, 'fadeout', interval);
	};
	
	/**
	* フェードイン
	* @method
	* @param target {Object} 対象DOMObject
	* @param duration {Number} 所要時間
	* @param callback {Function} コールバック関数
	*/
	exports.fadeIn = function(target, duration, callback) {
		var c = Math.floor(duration / FRAME_RATE)
			, interval
			, op = 0
			, factor = 1 / c
			, engine;

		if (!target || target.style.opacity == '1' || checkAnimate(target, 'fadein')) {
			return;
		}
		exports.cancelAnimation(target, 'fadeout');
		exports.setOpacityZero(target);
		target.style.display = 'block';
		target.style.visibility = 'visible';
		if (_disableAnimate.fade) {
			exports.setOpacityOne(target);
			target.style.display = 'block';
			if (callback) {
				callback.apply();
			}
			return;
		}

		engine = function() {
			op += factor;
			exports.setOpacityTo(target, op);
			--c;
			if (c === 0) {
				exports.setOpacityOne(target);
				target.style.display = 'block';
				clearInterval(interval);
				removeAnimate(target, 'fadein');
				if (callback) {
					callback.apply();
				}
			}// else {
				//return _enterFrame(engine);
			//}
		};
		//interval = engine();
		interval = setInterval(engine, FRAME_RATE);
		addAnimate(target, 'fadein', interval);
	};
	
	/**
	* アニメーションをキャンセルする
	* @param target {Object} 対象
	* @param type {String} アニメーションタイプ 'fadein', 'fadeout'
	*/
	exports.cancelAnimation = function(target, type) {
		var i, len = animations.length, anim;
		
		for (i = 0; i < len; ++i) {
			anim = animations[i];
			if (anim.type === type && anim.target === target) {
				clearInterval(anim.interval);
				removeAnimate(target, type);
				return true;
			}
		}
		return false;
	};
	
	/**
	* 任意のアニメーションを取得する
	* @param target {Object} 対象
	* @param type {String} アニメーションタイプ 'fadein', 'fadeout' ...
	*/
	exports.getAnimation = function(target, type) {
		var i, len = animations.length, anim;
		for (i = 0; i < len; ++i) {
			anim = animations[i];
			if (anim.type === type && anim.target === target) {
				return anim;
			}
		}
		return null;
	};
	
	/**
	* 対象オブジェクトの透明度取得
	* @method
	* @param target {Object} 対象
	*/
	exports.getOpacity = function(target) {
		if (_userAgent.ie <= 8) {
			return target.style.filter.replace(/\D/mg, '') / 100;
		} else {
			return target.style.opacity;
		}
	};
	
	/**
	* 透明度を0にする
	* @param target {Object} ターゲットオブジェクト
	*/
	exports.setOpacityZero = function(target) {
		if (_userAgent.ie <= 8) {
			target.style.visibility = 'hidden';
		} else if (_disableAnimate.fade) {
			target.style.visibility = 'hidden';
			target.style.opacity = 0;
		} else {
			target.style.opacity = 0;
		}
	};
	
	/**
	* 透明度を1にする
	* @param target {Object} ターゲットオブジェクト
	*/
	exports.setOpacityOne = function(target) {
		if (_userAgent.ie <= 8) {
			target.style.visibility = 'visible';
		} else if (_disableAnimate.fade) {
			target.style.visibility = 'visible';
			target.style.opacity = 1;
		} else {
			target.style.opacity = 1;
		}
	};
	
	/**
	* 透明度を指定した値に変更する
	* @param target {Object} ターゲットオブジェクト
	* @param opacity {Number} 0-1 透明度
	*/
	exports.setOpacityTo = function(target, opacity) {
		if (!_disableAnimate.fade) {
			target.style.opacity = opacity;
		}
	};

	/**
	* enterFrameエンジン取得
	* @return {Function} callback, element
	*/
	exports.requestAnimationFrame = function() {
		return _enterFrame;
	}

	/* ------------------------------------------------------------
	* Mouse Event
	* ------------------------------------------------------------*/
	/**
	* 任意のエレメントにおけるマウス座標の取得
	* @param e {Object} targetElement
	* @param evt {Object} EventObject
	* @return {Object} 座標オブジェクト
	*/
	exports.getMouseOffset = function(e, evt){
		var ev = evt || window.event,
			ePos = getPosition(e),
			mousePos = mouseCoords(ev);
		return {x:mousePos.x - ePos.x, y:mousePos.y - ePos.y};
	};
	
	
	/**
	* ドラッグドロップ
	* @method
	* @param id_ {String} 対象エレメントのID
	* @param _max {Number} 最大移動座標
	*/
	exports.setDragDrop = function(id_, _max) {
		
		var dragDrop = {
			element: null,
			mouseOffset: null,
			minX: 0,
			maxX: _max,
			mouseCoords: function(evt){
				if(evt.pageX || evt.pageY){
					return {x:evt.pageX, y:evt.pageY};
				}
				return {
					x:evt.clientX + document.body.scrollLeft - document.body.clientLeft,
					y:evt.clientY + document.body.scrollTop  - document.body.clientTop
				};
			},
			getMouseOffset: function(e, evt){
				var ev = evt || window.event;
				var ePos = dragDrop.getPosition(e);
				var mousePos = dragDrop.mouseCoords(ev);
				return {x:mousePos.x - ePos.x, y:mousePos.y - ePos.y};
			},
			getPosition: function(e){
				var left = 0,
					top = 0;
				left += e.offsetLeft;
				top += e.offsetTop;
				return {x: left, y: top};
			},
			mouseMove: function(evt){
				var ev = evt || window.event,
					mousePos = dragDrop.mouseCoords(ev),
					e = dragDrop.element,
					_x;
				if(e){
					_x = mousePos.x - dragDrop.mouseOffset.x;
					_x = Math.max(0, Math.min(_x, dragDrop.maxX));
					e.style.left = _x + "px";
					return false;
				}
			},
			mouseUp: function(){
				dragDrop.element = null;
			},
			attach: function(e){
				if (!e) {
					return;
				}
				e.onmousedown = function(evt){
					dragDrop.element = this;
					dragDrop.mouseOffset = dragDrop.getMouseOffset(this, evt);
					return false;
				}
			}
		};
		
		dragDrop.attach(Sizzle('#' + id_)[0]);
		return dragDrop;
	};
	
	/* ------------------------------------------------------------
	* Cookie
	* ------------------------------------------------------------*/
	
	/**
	* Cookieの取得
	* @param key {String}
	* @return {String} value
	*/
	exports.getCookie = function(key) {
		var tmp1, tmp2, len,
			xx1, xx2, xx3;
		
		xx1 = xx2 = 0;
		tmp1 = ' ' + document.cookie + ';';
		len = tmp1.length;
		while (xx1 < len) {
			xx2 = tmp1.indexOf(';', xx1);
			tmp2 = tmp1.substring(xx1 + 1, xx2);
			xx3 = tmp2.indexOf('=');
			if (tmp2.substring(0, xx3) == key) {
				return (unescape(tmp2.substring(xx3 + 1, xx2 - xx1 - 1)));
			}
			xx1 = xx2 + 1;
		}
		return '';
	};
	
	/**
	* Cookieの設定
	* @param key {String}
	* @param value {String, Number}
	* @param once {Boolean}
	* @param path {String}
	*/
	exports.setCookie = function(key, val, once, path) {
		var tmp;
		tmp = key + '=' + escape(val) + '; ';
		if (!once) {
			tmp += 'expires=Tue, 31-Dec-2030 23:59:59; ';
		}
		if (path) {
			tmp += 'path=' + path + '; ';
		}
		document.cookie = tmp;
	};
	
	/* ------------------------------------------------------------
	* Ajax
	* ------------------------------------------------------------*/
	/**
	* JSONデータ読み込み・取得
	* @param url {String} 読み込みJSON URL
	* @param callback {Function} コールバック関数
	* @param error {Function} エラー処理関数
	*/
	exports.getJSON = function(url, callback, error) {
		var xhReq = createXMLHttpRequest(),
			requestTimer = setTimeout(function () {
				xhReq.abort();
			}, 10000);
		xhReq.open("GET", url, true);
		//xhReq.setRequestHeader('Content-Type', 'applicaton/json; charset=utf-8');
		xhReq.onreadystatechange = function() {
			if (xhReq.readyState != 4) {
				return
			}
			clearTimeout(requestTimer);
			if (xhReq.status != 200) {
				if (error) {
					error.apply(this, [{
						message: 'budRequest:' + xhReq.status
					}]);
				}
				return;
			}
			var serverResponse = xhReq.responseText;
			callback.apply(this, [serverResponse]);
			
		};
		xhReq.send(null);
		function createXMLHttpRequest() {
			try {
				return new XMLHttpRequest();
			} catch (e) {
				
			}
			try {
				return new ActiveXObject("Msxml2.XMLHTTP");
			} catch (e) {
				
			}
			try {
				return new ActiveXObject("Microsoft.XMLHTTP");
			} catch (e) {
				
			}
			return null;
		}
	};
	/* ------------------------------------------------------------
	* Array
	* ------------------------------------------------------------*/
	/**
	* getUniqueArray
	* @param array {Array}
	* @return {Array} Unique Array
	*/
	exports.arrayUnique = function(array) {
		var newArray = array.concat(),
			len = newArray.length,
			i, j;
		for (i = 0; i < len; i += 1) {
			for(j = i + 1; j < len; j += 1) {
				if (newArray[i] === newArray[j]) {
					newArray.splice(j, 1);
				}
			}
		}
		return newArray;
	};
	
	exports.arrayGC = function(array) {
		var i, len = array.length,
			result = [];
		for (i = 0; i < len; ++i) {
			if (array[i] !== undefined && array[i] !== null) {
				result[result.length] = array[i];
			}
		}
		return result;
	};
	
	/* ------------------------------------------------------------
	* Observer
	* ------------------------------------------------------------*/
	/**
	* Window LOADイベントのエイリアス
	*/
	exports.onReady = function(func) {
		var i
			, len;
		if (typeof func === 'function') {
			for (i = 0, len = _onReadyFuncs.length; i < len; ++i) {
				if (_onReadyFuncs[i] === func) {
					return false;
				}
			}
			exports.addEventListener(window, 'load', func);
			_onReadyFuncs[_onReadyFuncs.length] = func;
			return true;
		}
		return false;
	};

	/* ------------------------------------------------------------
	* Helper
	* ------------------------------------------------------------*/
	/**
	 * クラス名を追加する
	 * @param element {Element Object} 対象エレメント
	 * @param name {String} クラス名
	 */
	exports.addClassName = function(element, name) {
		if (element.className.search(name) === -1) {
			if (element.className) {
				element.className += ' ' + name;
				/** 2012.10.11 add START */
				element.className = element.className.replace(/\s+/mg, ' ');
				/** 2012.10.11 add END */
			} else {
				element.className = name;
			}
		}
	};

	/**
	* @param {Array} list 捜索対象リスト
	* @param {Function} method 実行関数
	* @param ...list
	*/
	exports.each = function(list, method) {
		var i
			, len
			, target;

		if (!list || !method) {
			throw Error('list, method を指定してください。');
		}
		arguments.slice = Array.prototype.slice;
		for (i = 0, len = list.length; i < len; ++i) {
			target = list[i];
			if (method) {
				method.apply(target, [i].concat(arguments.slice(2)));
			}
		}
	};

	/**
	 * クラス名を削除する
	 * @param element {Element Object} 対象エレメント
	 * @param name {String} クラス名
	 */
	exports.removeClassName = function(element, name) {
		element.className = element.className.replace(name, '');
		if (element.className.search(name) !== -1) {
			exports.removeClassName(element, name);
		} else {
			if (element.className.search(/\s+/mg) !== -1) {
				element.className = element.className.replace(/\s+/, ' ');
			}
		}
	};

	/**
	* @param name {String} className
	* @return {Array}
	*/
	exports.getElementsByClassName = function(name) {
		var _classname = document.getElementsByClassName
			, doms = document.getElementsByTagName("*")
			, i
			, len
			, results = [];

		if (typeof _classname === 'function') {
			return document.getElementsByClassName(name);
		} else {
			for (i = 0, len = doms.length; i < len; ++i) {
				if (doms[i].className === name) {
					results[results.length] = doms[i];
				}
			}
			return results;
		}
	};

	/**
	 * 実態参照に変換する
	 * @param str {String}
	 * @return {String}
	 */
	exports.escapeHTML = function(str) {
		str = str.replace(/&/g, '&amp;');
		str = str.replace(/"/g, '&quot;');
		str = str.replace(/'/g, '&#039;');
		str = str.replace(/</g, '&lt;');
		str = str.replace(/>/g, '&gt;');
		return str;
	};
	
	/**
	* ターゲットの子ノードを削除する
	* @param node {Element} 対象のノード
	*/
	exports.clearNode = function(node) {
		var i, len, childs = node.children;
		for (i = 0, len = childs.length; i < len; ++i) {
			node.removeChild(childs[0]);
		}
	};

	/**
	* 指定のnodeを親から取り外す
	* @param {Element} node
	*/
	exports.removeNode = function(node) {
		var par = node.parentNode;
		par.removeChild(node);
	};
	
	/**
	* groupリスト内DOMノードの高さを揃える
	* @method
	* @param group {Array} 
	* @param offsetH {Number}
	* @return {Number} 指定された高さを返す
	*/
	exports.flatHeight = function(group) {
		var i
			, len
			, best = 0
			, _offset
			, _tag
			, _style
			, _top
			, _bottom
			, _borderTop
			, _borderBottom;
		for (i = 0, len = group.length; i < len; ++i) {
			_tag = group[i];
			if (_tag) {
				_style = exports.getComputedStyle(_tag);
				_top = parseInt(_style.paddingTop.replace('px', ''), 10);
				_bottom = parseInt(_style.paddingBottom.replace('px', ''), 10);
				_borderTop = parseInt(_style.borderTopWidth.replace('px', ''), 10) || 0;
				_borderBottom = parseInt(_style.borderBottomWidth.replace('px', ''), 10) || 0;
				offsetH = _top + _bottom + _borderTop + _borderBottom;
				best = Math.max(best, group[i].offsetHeight - offsetH);
			}
		}
		for (i = 0; i < len; ++i) {
			if (group[i]) {
				group[i].style.height = best + 'px';
			}
		}
		return best;
	};

	/**
	* 内部の要素まで指定してflatHeightを実行
	* @method
	* @param lists {Array} 親のリスト
	* @param targets {Array}　グループ内でそろえたいセレクタのリスト
	*/
	exports.setGroupFlatHeight = function(lists, targets) {
		var i
			, j
			, len
			, jlen
			, group;
		
		if (!lists || !targets) {
			return;
		}
		
		for (i = 0, len = lists.length; i < len; i++) {
			group = lists[i];
			for (j = 0, jlen = targets.length; j < jlen; j++) {
				exports.flatHeight(Sizzle(targets[j], group));
			}
		}
	};

	/**
	* @param element {ElementObject}
	* @return {Object}
	*/
	exports.getComputedStyle = function(element) {
		if (!element) {
			return null;
		}
		return element.currentStyle || document.defaultView.getComputedStyle(element, '');
	};

	/**
	* バナー用のボーダーを設定
	* @param bannerList {Array} <a></a><img>を包括した<li>のリスト
	*/
	exports.setBannerBorder = function(bannerList) {
		var banner, i, len;
		if (!bannerList || !_userAgent.ie) {
			return;
		}
		for (i = 0, len = bannerList.length; i < len; ++i) {
			banner = bannerList[i];
			exports.addEventListener(banner, 'mouseover', function(i) {
				return function() {
					var index = i,
						_a;
					_a = Sizzle('a', bannerList[index])[0];
					if (!_a || _a.href === 'javascript:void(0);') {
						return;
					}
					bannerList[index].style.cursor = 'pointer';
					_a.className = 'on';
				};
			}(i));
			exports.addEventListener(banner, 'mouseout', function(i) {
				return function() {
					var index = i,
						_a;
					_a = Sizzle('a', bannerList[index])[0];
					if (!_a) {
						return;
					}
					bannerList[index].style.cursor = 'default';
					_a.className = '';
				};
			}(i));
			exports.addEventListener(banner, 'click', function(i) {
				return function() {
					var index = i,
						_a;
					_a = Sizzle('a', bannerList[index])[0];
					if (!_a) {
						return;
					}
					if (_a.target === '_blank') {
						window.open(_a.href);
					} else {
						location.href = _a.href;
					}
				};
			}(i));
		}
	};

	/**
	* <li><a style="position: absolute"></a></li>な構造のマウスオーバー処理を追加する(for IE)
	* @param lists {Array}
	* @description ブロック要素の<li>内にただひとつ<a>が存在している状況でボックスリンクを再現する。IEの時のみ実行すればよい
	*/
	exports.setContentsBorder = function(lists) {
		var i
			, len
			, li
			, _a
			, link
			, _tag;
		
		if (!lists || !_userAgent.ie) {
			return;
		}
		for (i = 0, len = lists.length; i < len; ++i) {
			li = lists[i];
			_a = Sizzle('a', li)[0];

			if (!_a || _a.href.search('javascript') != -1) {
				if (_a) {
					_a.style.display = 'none';
				}
				continue;
			}

			link = _a.href;
			_a.href = 'javascript:void(0)';
			_a.rel = link;
			_a.target = _a.target || '_self';
			
			li.onclick = function(e) {
				var a = Sizzle('a', this)[0];
				if (a.target === '_self') {
					location.href = a.rel;
				} else {
					window.open(a.rel, a.target);
				}
			};
			li.onmouseover = function (e) {
				if (this.className === 'none') {
					return;
				}
				exports.addClassName(this, 'on');
			};
			li.onmouseout = function (e) {
				exports.removeClassName(this, 'on');
			};

			_a.style.display = 'none';
		}
	};

	/**
	* for Software Small draw boarder
	* @param {Array} lists
	*/
	exports.addLineupHover = function(lists) {
		var li
			, _a
			, link
			, i
			, len;

		if (!lists) {
			return;
		}

		len = lists.length;
		for (i = 0; i < len; ++i) {
			li = lists[i];
			_a = Sizzle('a', li.children[0])[0];

			if (!_a) {
				continue;
			}
			
			link = _a.href;
			_a.href = 'javascript:void(0)';
			_a.rel = link;
			
			li.onclick = function() {
				location.href = this.children[0].children[0].rel;
			}
			
			li.onmouseover = function (event) {
				var _div;
				if (this.className === 'none') return;
				_div = Sizzle('div', this)[0];
				if(!_div.className.match('over'))
				{
					_div.className = _div.className + '-over'
				}
			};
			
			li.onmouseout = function (event) {
				var _div;
				if (this.className === 'none') return;
				_div = Sizzle('div', this)[0];
				if(_div.className.match('-over'))
				{
					_div.className = _div.className.replace('-over', '');
				}
			};
		}
	};

	/**
	* UUID(仮)を取得
	* @param {Boolean} useAttrSyntax 属性値指定可能書式で取得
	* @return {String}
	*/
	exports.getUUID = function(useAttrSyntax) {
	    var S4 = function() {
	        return (((1 + Math.random()) * 0x10000)|0).toString(16).substring(1);
	    };
	    return useAttrSyntax ? 'a' + S4() + S4() + S4() + S4() + S4() + S4() + S4() + S4() : (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() +S4());
	};
	
	return exports;
}());
/**
* 共有実行
* @namespace SCE_APP
* @class common
*/
SCE_APP.factory.Module.create('common', SCE_APP, false, (function () {

	var _util = SCE_APP.Utility
		, exports = {};
	_util.addEventListener(window, 'load', function () {
		var util = _util
			, ua = util.getUseragent();
		
		//Current
		util.setCurrentFormat(Sizzle('body')[0].id, Sizzle('body')[0].className);
		
		//Return To Top Button
		function setupReturnToTop() {
			var returnToTop
				, _style;
			returnToTop = document.getElementById('return-to-top-button');
			if (!returnToTop) {
				return;
			}
			util.fadeIn(returnToTop, 400);
			util.addEventListener(returnToTop, 'click', function () {
				var offset = window.pageYOffset ? window.pageYOffset : (document.body.scrollTop || document.documentElement.scrollTop);
				if (offset !== 0) {
					util.scrollToPosition(window, [0, 0]);
				}
			});
			
			_style = returnToTop.style;
			if (ua.ps3) {
				_style.opacity = 1;
				_style.visibility = 'visible';
			}
			
			if (ua.vita) {
				util.clearNode(returnToTop);
				_style.positon = 'absolute';
				_style.width = 0;
				_style.height = 0;
			}
			
		}
		setupReturnToTop();
		
		/**
		* コンテンツ内部 ゲームタイトル検索のセットアップ
		*/
		function setupSearchBox() {
			var txt = document.getElementById('search-query'),
				submitbutton = document.getElementById('search-submit'),
				defaultTxt = 'ゲームに関するキーワードを入力してください。';
			
			if (!txt || !submitbutton) {
				return;
			}
			util.addEventListener(txt, 'focus', function () {
				if (txt.value === defaultTxt) {
					txt.value = '';
				}
			});
			util.addEventListener(txt, 'blur', function () {
				if (txt.value === '' || txt.value.match(/^\s+/)) {
					txt.value = defaultTxt;
				}
			});
			util.addEventListener(submitbutton, 'click', function () {
				if (txt.value === defaultTxt) {
					txt.value = '';
				}
				txt.value = util.escapeHTML(txt.value);
				return false;
			});
			
			util.addEventListener(Sizzle('#menu-search-submit')[0], 'click', function () {
				var globalsearch = document.getElementById('menu-search-query');
				globalsearch.value = util.escapeHTML(globalsearch.value);
			});
		}
		setupSearchBox();
		
		/**
		* Contents Banner / Bottom Banner
		*/
		if (ua.ie) {
			util.setBannerBorder(Sizzle('#bottom-banners li'));
			util.setBannerBorder(Sizzle('#content-banner-wrapper li'));
		}
		
		/**
		* 既存のopenWindowメソッドの実装
		*/
		if (__global) {
			__global.openWindow = function (url, w, h) {
				window.open(url, "SCEPopupWindow", "width=" + (w || 400) + ",height=" + (h || 300));
			};
		}
		
		/* ------------------------------------------------------------
		* GLOBAL
		* ------------------------------------------------------------*/
		/**
		* mboxリンククリック時
		*/
		window.mboxOnClick = function (myMbox, clickedOnValue, myLocation, target) {
			try {
				mboxUpdate(myMbox, 'clickedOn=' + clickedOnValue);
			} catch(e) {
				
			}
			if (target === '_blank') {
				window.open(myLocation);
			} else {
				setTimeout(function () {
					location.href = myLocation;
				},500);
			}
		};
		
		/**
		* ビルボードクリック時
		*/
		window.onBillboardlinkClick = function (alt_, image_, url_, window_, type_) {
			if (s) {
				s.linkTrackVars = 'eVar43,events,products';
				s.linkTrackEvents ='event39';
				s.events = 'event39';
				s.products = ";;;;;eVar43=" + s.getBannerFirstCat() + 'main:' + alt_;

				try {
					s.tl(this,'o','click main banner');
				} catch(e) {
					
				}
				window.mboxOnClick(type_, image_, url_, window_);
			}
		};

		/**
		* 「SCEJからの重要なお知らせ」表示制御
		*/
		(function setupImportant() {
			var tags = getImportantTargets()
				, tag
				, closeButton
				, unvisibleCheck
				, newsDate
				, i
				, len = tags.length;
				
			for (i = 0; i < len; ++i) {
				tag = tags[i];
				closeButton = Sizzle('.most-important-submit-button, #most-important-submit-button-d', tag)[0];
				unvisibleCheck = Sizzle('.most-important-check, #most-important-type-d-check', tag)[0];
				if (tag && closeButton) {
					newsDate = Sizzle('.most-important-date, #most-important-date', tag)[0].childNodes[0].nodeValue;
					tag.style.display = '';
					if (util.getCookie('c' + newsDate) === '1') {
						tag.style.display = 'none !important';
						util.clearNode(tag);
					} else {
						tag.style.display = 'block';
						tag.style.visibility = 'visible';
					}
					util.addEventListener(closeButton, 'click', function () {
						var _tag = tag
							, _unvisibleCheck = unvisibleCheck
							, _newsDate = newsDate;
						return function () {
							if (_unvisibleCheck.checked) {
								util.setCookie('c' + _newsDate, 1, false, '/');
							}
							_tag.style.display = '';
							util.clearNode(_tag);
						}
					}());
				}
			}
			
			function getImportantTargets() {
				var ID_LIST = ['b', 'c', 'd']
					, result = []
					, i
					, len;
				
				for (i = 0, len = ID_LIST.length; i < len; ++i) {
					result[result.length] = document.getElementById('most-important-type-' + ID_LIST[i]);
					result[result.length] = document.getElementById('most-important-survey-type-' + ID_LIST[i]);
				}
				
				return util.arrayGC(result);
			}
		}());
	});
	/* ------------------------------------------------------------
	* Exports
	* ------------------------------------------------------------*/
	exports.setupLineupWrap = function (selector) {
		var lineupUlList = Sizzle(selector)
			, i
			, len
			, j
			, lenj
			, _ul
			, _li
			, _lis
			, _targets;
			
		if (!lineupUlList || !lineupUlList.length) {
			lineupUlList = Sizzle('#lineup-area ul');
		}

		for (i = 0, len = lineupUlList.length; i < len; ++i) {
			_targets = [];
			_ul = lineupUlList[i];
			_lis = Sizzle('li', _ul);
			for (j = 0, lenj = _lis.length; j < lenj; ++j) {
				_li = _lis[j];
				_targets[_targets.length] = Sizzle('div', _li)[0];
				_targets[_targets.length] = Sizzle('.titlelink', _li)[0];
			}

			_util.flatHeight(_targets);
		}
	};
	
	return exports;
}()));

/**
* ScrollToAnchor
* @namespace SCE_APP.view
* @class Carousel
*/

SCE_APP.namespace('view');
SCE_APP.view.ScrollToAnchor = (function() {
	var util = SCE_APP.Utility
		, SCROLL_TO_CLASSNAME = 'scrollto'
		, anchors = []
		, exports = {};
	
	function addAnchorListeners() {
		var i
			, len
			, anc;
		
		function afterAnchorClicked(e) {
			var selector,
				tag;
				
			if (this.rel) {
				tag = this.rel;
			} else {
				if (this.href) {
					location.href = this.href;
				}
				return;
			}
			selector = tag.match(/[^\/]*$/);
			if (selector && selector[0]) {
				setTimeout(function() {
					util.scrollToTarget(Sizzle(selector[0])[0]);
				}, 100);
			}
			util.cancelEvent(e);
			return false;
		}
		
		for (i = 0, len = anchors.length; i < len; ++i) {
			anc = anchors[i];
			util.addEventListener(anc, 'click', util.bind(anc, afterAnchorClicked));
		}
	}
	
	
	/* ------------------------------------------------------------
	* Exports
	* ------------------------------------------------------------*/
	/**
	* 初期化
	* @param setting {Object}
	*/
	exports.init = function() {
		anchors = Sizzle('.' + SCROLL_TO_CLASSNAME);
		addAnchorListeners();
	};

	/**
	* セレクタを指定してアンカーを設定
	* @param selector {String}
	*/
	exports.setupWithSelector = function(selector) {
		if (!selector) {
			return;
		}
		anchors = Sizzle(selector);
		addAnchorListeners();
	};
	
	util.onReady(function() {
		exports.init();
	});
	return exports;
	
}());
/**
* SCE_APP
* dependence on Sizzle.js
*/

var SCE_APP = SCE_APP || {};

/**
* @namespace SCE_APP
* @module globalMenu
*/
SCE_APP.globalMenu = (function() {
	/* ------------------------------------------------------------
	* private static
	* ------------------------------------------------------------*/
	var _menus = [],
		_isInit = false;
	
	/* ------------------------------------------------------------
	* private Method
	* ------------------------------------------------------------*/
	/**
	* 指定のオブジェクトを覗いたサブメニューの非表示
	* @param without {Object} 非表示させないDOMオブジェクト
	*/
	function hideSubMenuWithout(without) {
		var i, len, node;
		for (i = 0, len = _menus.length; i < len; ++i) {
			node = _menus[i];
			if (node.subMenu) {
				if (without && node.menu.id === without.id) {
					node.a.className = 'on';
					node.subMenu.style.display = 'block';
				} else {
					node.a.className = '';
					node.subMenu.style.display = 'none';
				}
			}
		}
	}
	
	/**
	* メニュー作成
	*/
	function createMenu() {
		var list = ['menu-home', 'menu-ps3', 'menu-vita', 'menu-psp', 'menu-psn', 'menu-psc', 'menu-search'],
			subList = ['', 'sub-menu-ps3', 'sub-menu-vita', 'sub-menu-psp', 'sub-menu-psn', 'sub-menu-psc', ''],
			i,
			len,
			menu, submenu,
			util = SCE_APP.Utility;
			
		for (i = 0, len = list.length; i < len; ++i) {
			menu = document.getElementById(list[i]);
			submenu = document.getElementById(subList[i]) || null;
			_menus[_menus.length] = {
				menu: menu,
				a: Sizzle('a:first', menu)[0],
				subMenu: submenu
			};
			
			util.addEventListener(menu, 'mouseover', function(_i) {
				return function(e) {
					hideSubMenuWithout(_menus[_i].menu);
				};
			}(i));
			
			util.addEventListener(menu, 'mouseout', function() {
				hideSubMenuWithout();
			});
		}
	}
	
	/**
	* メニュー部検索BOXセットアップ
	*/
	function setupMenuSearch() {
		var searchButton,
			searchArea,
			searchRadioSite,
			searchRadioSoft,
			searchCheckQA,
			searchWrap,
			siteLabel,
			softLabel,
			qaLabel,
			group,
			searchRight, _isSearch = false;
			
		searchButton = document.getElementById('menu-search-button');
		searchArea = document.getElementById('sub-menu-search');
		searchRadioSoft = document.getElementById('menu-search-soft');
		searchRadioSite = document.getElementById('menu-search-site');
		searchCheckQA = document.getElementById('menu-search-qa');
		searchWrap = document.getElementById('menu-search-wrap');
		searchRight = document.getElementById('menu-search-right');
		siteLabel = document.getElementById('menu-search-site-label');
		softLabel = document.getElementById('menu-search-soft-label');
		qaLabel = document.getElementById('menu-search-qa-label');
		group = document.getElementById('menu-search-group');

		/**
		 * サイト内検索クリック時
		 */
		util.addEventListener([siteLabel, searchRadioSite], 'click', function() {
			setTimeout(function() {
				siteLabelClicked();
				setGroup('0');
			}, 200);
		});

		function siteLabelClicked() {
			searchCheckQA.disabled = false;
			util.addClassName(siteLabel, 'on');
			util.removeClassName(softLabel, 'on');
			util.removeClassName(qaLabel, 'qadisable');
		}

		/**
		 * ゲームタイトル検索クリック時
		 */
		util.addEventListener([searchRight, searchRadioSoft], 'mouseup', function() {
			setTimeout(function() {
				setGroup('1');
				searchCheckQA.checked = false;
				searchCheckQA.disabled = true;
				util.removeClassName(qaLabel, 'qaon');
				util.removeClassName(qaLabel, 'qaoff');
				util.addClassName(qaLabel, 'qadisable');
				util.addClassName(softLabel, 'on');
				util.removeClassName(siteLabel, 'on');
			}, 100);
		});

		/**
		 * QAチェンジ時
		 */
		util.addEventListener([qaLabel, searchCheckQA], 'click', function() {
			if (softLabel.className) {
				siteLabelClicked();
				searchRadioSite.select();
				searchRadioSite.checked = true;
			}
			setTimeout(function() {
				changeQAcheck();
			}, 200);
		});

		function setGroup(value) {
			if (group) {
				group.value = value;
			}
		}

		function changeQAcheck() {
			var checked;
			if (searchCheckQA) {
				checked = searchCheckQA.checked;
			} else {
				return;
			}
			setGroup('0');
			if (checked) {
				util.removeClassName(qaLabel, 'qaoff');
				util.addClassName(qaLabel, 'qaon');
			} else {
				util.addClassName(qaLabel, 'qaoff');
				util.removeClassName(qaLabel, 'qaon');
			}
		}
		changeQAcheck();
		
		util.addEventListener(searchButton, 'click', function() {
			var searchbox = document.getElementById('sub-menu-search'),
				onDocumentClicked, onSearchClicked;
				
			if (!_isSearch) {
				searchButton.className = 'on';
				util.setOpacityZero(searchArea);
				util.fadeIn(searchArea, 100);
				
				onDocumentClicked = function() {
					if (_isSearch) {
						searchButton.className = '';
						_isSearch = false;
						util.fadeOut(searchArea, 100);
						util.removeEventListener(searchbox, 'click', onSearchClicked);
						util.removeEventListener(document, 'click', onDocumentClicked);
					}
				};
				
				onSearchClicked = function() {
					_isSearch = false;
					setTimeout(function() {
						_isSearch = true;
					}, 100);
				};
				
				setTimeout(function() {
					util.addEventListener(document, 'click', onDocumentClicked);
					util.addEventListener(searchbox, 'click', onSearchClicked);
				}, 200);
				_isSearch = true;
			}
		});
	}
	
	/* ------------------------------------------------------------
	* Exports
	* ------------------------------------------------------------*/
	var exports = function() {}
		, util = SCE_APP.Utility;
	
	/**
	* 初期化
	* @method
	*/
	exports.init = function() {
		if (_isInit) {
			return;
		}
		createMenu();
		setupMenuSearch();
		_isInit = true;
	};
	
	util.addEventListener(window, 'load', function() {
		exports.init();
	});
	return exports;
}());

/**
* callback用Object
*/
SCE_APP.namespace('callback');
SCE_APP.namespace('manager.youtubeManager');

/**
* Youtube Player Manager Module
*/
SCE_APP.manager.youtubeManager = (function () {
	var exports = {}
		, _util = SCE_APP.Utility
		, _THUMB_API = 'http://gdata.youtube.com/feeds/api/videos/'
		, _YT_URL = 'http://www.youtube.com/watch?v='
		, _PLAYMOVIE_URL = 'http://www.youtube.com/watch?v='
		, _records = []
		, _delegate
		, _len = 0
		, _thumbLen = 0
		, _isCreate = false
		, _done = false;

	/**
	* 作成を実行
	*/
	function createPlayer() {
		var useThumbs = [];

		if (_isCreate) {
			return;
		}
		_isCreate = true;
		_thumbLen = 0;
		_util.each(_records, function () {
			if (this.settings.thumb && this.settings.thumb !== '0') {
				_thumbLen++;
				_util.bind(this, loadThumbnail, [this.target, this.settings])();
				return;
			}
			execCreatePlayer(this);
		});

		tryCreated();
	}

	/**
	* @param {Object} record
	* @param {Boolean} isThumb サムネイルクリックから作成されたかの真偽値
	*/
	function execCreatePlayer(record, isThumb) {
		if (isThumb) {
			record.settings.playerVars.autoplay = 1;
		}
		record.player = new YT.Player(record.target, record.settings);
	}

	/**
	*
	*/
	function tryCreated() {
		if (_delegate && typeof _delegate.complete === 'function') {
			if (_thumbLen === 0) {
				_delegate.complete.apply(this);
			}
		}
	}
	
	/**
	* サムネイルなどの情報を読み込む
	* @param {Element} tag
	* @param {Object} _s setting object
	*/
	function loadThumbnail(tag, s_) {
		var s = s_
			, that = this;
		$.ajax({
			url: _THUMB_API + s.videoId + '?alt=json-in-script',
			dataType: 'jsonp',
			success: function (res) {
				that.description = res.entry.media$group.media$description.$t;
				if (!that.title) {
					that.title = res.entry.media$group.media$title.$t;
				}
				_util.bind(that, createThumbnail, [tag, res.entry.media$group])();
			}
		});
	}

	/**
	* サムネイルの作成
	* @param {Element} tag
	* @param {Object} group
	* gen-movie-thumb 0: player, 1: click->player, 2: playOnYoutube, 3:playOnPlaymovies
	*/
	function createThumbnail(tag, group) {
		var img = new Image()
			, timeArea = document.createElement('div')
			, overArea = document.createElement('div')
			, thumb = group['media$thumbnail'][0]
			, time = group['yt$duration'].seconds
			, t = $('#' + tag)
			, ar
			, that = this
			, th = this.settings.thumb;

		t.empty();

		ar = thumb.url.split('/');
		ar.pop();
		ar = ar.join('/');

		timeArea.className = 'gen-movie-time';
		timeArea.appendChild(document.createTextNode(getMovieDuration(time)));

		overArea.className = 'gen-movie-mover';
		overArea.style.height = this.settings.height + 'px';
		overArea.style.backgroundPosition = 'center ' + (this.settings.height / 2 - 27) + 'px';

		if (setThumbnailLink(overArea, this)) {
			t.append(overArea);
		} else {
			t.bind('click', function () {
				if (th === '20') {
					window.open(_YT_URL + that.settings.videoId + '&feature=autoplay');
				} else if (th === '30') {
					location.href = _PLAYMOVIE_URL + that.settings.videoId;
				}
			});
		}

		img.src = ar + '/mqdefault.jpg';
		img.width = this.settings.width;
		img.height = this.settings.height;
		img.className = 'gen-movie-thumb-image';
		img.alt = this.title;

		t.bind('mouseover', function (ev) {
			$(overArea).show();
		});
		
		t.bind('mouseout', function (ev) {
			$(overArea).hide();
		});

		$(overArea).hide();
		t.prepend(timeArea);
		t.prepend(img);

		_thumbLen--;
		tryCreated();
	}

	function setThumbnailLink(overArea, record) {
		var th = record.settings.thumb
			, videoId = record.settings.videoId;

		if (th === '1') {
			overArea.className += ' gen-movie-mover-atonce';
			bindOverArea();
			return true;
		} else if (th === '2') {
			overArea.className += ' gen-movie-mover-youtube';
			bindOverArea();
			return true;
		} else if (th === '3') {
			overArea.className += ' gen-movie-mover-playmovies';
			bindOverArea();
			return true;
		}

		function bindOverArea() {
			$(overArea).bind('click', function () {
				if (th === '1') {
					execCreatePlayer(record, true);
				} else if (th === '2' || th === '20') {
					window.open(_YT_URL + videoId + '&feature=autoplay');
				} else if (th === '3' || th === '30') {
					location.href = _PLAYMOVIE_URL + videoId;
				}
			});
		}
		
		return false;
	}

	/**
	* 再生時間表示のフォーマットをssss.. からhh:mm:ss へ変更します。
	* @param {Number} tim
	* @return {String}
	*/
	function getMovieDuration(tim) {
		var h = Math.floor(tim / 3600)
			, m = Math.floor(tim / 60)
			, mm = tim - 60 * m
			, result;

		if (mm < 10) {
			mm = '0' + mm;
		}
		result = h ? h + ':' : '';
		result += m + ':' + mm;
		return result;
	}

	/**
	* 準備完了の真偽を設定
	* @param {Boolean} done
	*/
	exports.setDone = function (done) {
		_done = done;
	};

	/**
	* 準備完了の真偽を取得
	*/
	exports.getDone = function () {
		return _done;
	};

	/**
	* 委譲オブジェクトを設定
	* @param {Object} del
	*/
	exports.setDelegate = function (del) {
		_delegate = del;
	};

	/**
	* (Youtubemovie)カウントの増加
	*/
	exports.incMovieLength = function () {
		_len++;
	};

	/**
	* @return {Number}
	*/
	exports.getMovieLength = function () {
		return _len;
	};

	/**
	* レコードに追加
	* @param {Object} settings
	* @param {Element} target
	* @param {String} title
	*/
	exports.addMovieInfo = function (settings, target, title) {
		_records[_records.length] = {
			settings: settings,
			target: target,
			title: title,
			tracked: false,
			entry: null
		};
	};

	exports.getMovieInfoAtPlayer = function (player) {
		var i
			, len = _records.length
			, rec;

		for (i = 0; i < len; ++i) {
			rec = _records[i];
			if (rec.player === player) {
				return rec;
			}
		}
	};

	/**
	* IDから動画情報を取得する
	*/
	exports.getMovieInfoAtId = function (id) {
		var result;
		_util.each(_records, function () {
			if (this.target === id) {
				result = this;
				return false;
			}
		});
		return result;
	};

	/**
	* player作成
	*/
	exports.tryCreatePlayers = function () {
		if (_records.length >= _len && _done) {
			createPlayer();
		}
	};

	/**
	* PlayMoviesのURLを取得
	*/
	exports.getPlayMovieURL = function () {
		return _PLAYMOVIE_URL;
	};

	exports.getYoutubeURL = function () {
		return _YT_URL
	};

	return exports;
}());

/**
* Movie Player
* @namespace SCE_APP.view
* @module moviePlayer
* @include Sizzle
*/

SCE_APP.namespace('view.moviePlayer');
SCE_APP.view.moviePlayer = (function (Si) {
	var util = SCE_APP.Utility
		, _manager = SCE_APP.manager.youtubeManager
		, _YT_PLAYER_CLASS = 'mp-youtube-area'
		, _BC_PLAYER_CLASS = 'mp-brightcove-area'
		, _CLASS_ID = '.gen-movie-id'
		, _CLASS_THUMB = '.gen-movie-thumb'
		, _CLASS_TITLE = '.gen-movie-title'
		, _CLASS_TYPE = '.gen-movie-type'
		, _CLASS_WIDTH = '.gen-movie-width'
		, _CLASS_HEIGHT = '.gen-movie-height'
		, _CLASS_PARAMS = '.gen-movie-params'
		, _DEFAULT_WIDTH = 609
		, _DEFAULT_HEIGHT = 371
		, _YT = 'youtube'
		, _BC = 'brightcove'

		, exports = {}
		, _elements

		, _listeners = []

		, _loadedY = false
		, _loadedB = false
		, _delegater = {};
	/**
	* 委譲オブジェクト
	*/
	_delegater.complete = function () {
		trigger(exports.READY);
	};

	function trigger(event) {
		var funcs = _listeners[event];
		if (funcs && funcs.length) {
			util.each(funcs, function () {
				this.apply(this);
			});
		}
	}

	/**
	* 動画設定の作成
	*/
	function setup() {
		_manager.setDelegate(_delegater);
		util.each(_elements, function () {
			var type = Si.getText(Si(_CLASS_TYPE, this))
				, width = Si.getText(Si(_CLASS_WIDTH, this)) || _DEFAULT_WIDTH
				, height = Si.getText(Si(_CLASS_HEIGHT, this)) || _DEFAULT_HEIGHT
				, title = Si.getText(Si(_CLASS_TITLE, this))
				, params = getVideoParams(Si(_CLASS_PARAMS, this))
				, settings;

			this.id = util.getUUID(true);
			
			settings = {
				height: height,
				width: width,
				videoId: Si.getText(Si(_CLASS_ID, this)),
				thumb: Si.getText(Si(_CLASS_THUMB, this)),
				playerVars: params,
				events: {
					'onStateChange': onPlayerStateChange
				}
			};

			if (type === _YT) {
				_manager.incMovieLength();
				createYoutubeMovie(settings, this.id, title);
			} else if (type === _BC) {
				createBrightcoveMovie(settings, this.id, title);
			}
		});
	}

	/**
	* パラメータの抽出
	* @param {Array}<Element> list
	* @return {Object}
	*/
	function getVideoParams(list) {
		var result = {};
		util.each(list, function () {
			var _key = this.className.replace('gen-movie-params ', '')
				, _value = Si.getText([this]);

			result[_key] =  _value;
		});
		return result;
	}

	/**
	* objectタグにパラメータを追加する
	* @param name {String}
	* @param value {String}
	* @param obj {Object} 対象オブジェクトタグ
	*/
	function addParam(name, value, obj) {
		var _param = document.createElement('param');

		_param.name = name;
		_param.value = value;
		obj.appendChild(_param);
	}

	/**
	* youtube動画を表示
	* @param settings {Object}
	* @param {String} targetのID
	* @param {String} title
	*/
	function createYoutubeMovie(settings, target, title) {
		if (!_loadedY) {
			_loadedY = true;
			util.requireScript('http://www.youtube.com/player_api', onScriptLoadedY);
		} else {
			onScriptLoadedY();
		}

		function onScriptLoadedY() {
			_manager.addMovieInfo(settings, target, title);
			_manager.tryCreatePlayers();
		}
	}

	/**
	* brightcove動画を表示
	* @param params {Object}
	* @param {String} title 動画のタイトル
	*/
	function createBrightcoveMovie(params, target, title) {
		if (!_loadedB) {
			util.requireScript('http://admin.brightcove.co.jp/js/BrightcoveExperiences.js', onScriptLoadedB);
		} else {
			onScriptLoadedB();
		}

		function onScriptLoadedB() {
			var CALLBACK_PREFIX = 'bc'
				, _obj = document.createElement('object')
				, _w = params.width
				, _h = params.height
				, _callback = SCE_APP.callback
				, _movie = document.getElementById(target);
			
			_obj.className = 'BrightcoveExperience';
			_obj.width = _w;
			_obj.height = _h;
			
			_callback[CALLBACK_PREFIX + params.videoId] = function (experienceID) {
				var player = brightcove.api.getExperience(experienceID)
					, modVP = player.getModule(brightcove.api.modules.APIModules.VIDEO_PLAYER)
					, modExp = player.getModule(brightcove.api.modules.APIModules.EXPERIENCE);
				modExp.addEventListener(brightcove.api.events.ExperienceEvent.TEMPLATE_READY, onTemplateReady);
				function onTemplateReady(evt) {
					modVP.addEventListener(brightcove.api.events.MediaEvent.BEGIN, onMediaEventFired);
				}
				function onMediaEventFired(evt) {
					if (evt.type == brightcove.api.events.MediaEvent.BEGIN) {
						if (s) {
							s.trackPlayVideo('BM:PlayCC:' + params.videoId + ':' + title);
						}
					}
				}
			}
			
			addParam('bgcolor', '#FFFFFF', _obj);
			addParam('width', _w, _obj);
			addParam('height', _h, _obj);
			addParam('playerID', util.getBrightcoveId(), _obj);
			addParam('playerKey', util.getBrightcoveKey(), _obj);
			addParam('isVid', 'true', _obj);
			addParam('isUI', 'true', _obj);
			addParam('wmode', 'transparent', _obj);
			addParam('dynamicStreaming', 'true', _obj);
			addParam('includeAPI', 'true', _obj);
			addParam('templateLoadHandler', 'SCE_APP.callback.' + CALLBACK_PREFIX + params.videoId, _obj);
			addParam('@videoPlayer', params.videoId, _obj);
			
			/*
			for (var i in params) {
				addParam(i, params[i], _obj);
			}
			*/
			_movie.appendChild(_obj);
			brightcove.createExperiences();
		}
	}

	/* ------------------------------------------------------------
	* Exports
	* ------------------------------------------------------------*/
	/**
	* 初期化処理
	* @param elements {Array}
	*/
	exports.init = function (elements) {
		var ua = util.getUseragent();

		_elements = elements;
		if (!_elements) {
			return;
		}
		/*
		if (ua.vita) {
			trigger(exports.DISABLE);
			return;
		}
		*/
		//util.requireScript('//ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js', setup);
		setup();
	};

	/**
	* イベント登録をする
	* @param {String} type
	* @param {Function} func
	*/
	exports.addEventListener = function (type, func) {
		var _funcs = _listeners[type] || [];
		_funcs[_funcs.length] = func;
		_listeners[type] = _funcs.slice();
	};

	exports.getMovieInfoAtId = function (id) {
		return _manager.getMovieInfoAtId(id);
	};

	/**
	* 全ての動画がコントロール可能な状態になったら実行されるイベント
	* @type {String}
	*/
	exports.READY = 'created';

	/**
	* ビデオが再生されない環境にて実行されるイベント
	* @type {String}
	*/
	exports.DISABLE = 'video_diabled';

	exports.getUsedMovieAtThumb = function (thumbIndex) {
		if (thumbIndex === '2' || thumbIndex === '20') {
			return _manager.getYoutubeURL();
		} else if (thumbIndex === '3' || thumbIndex === '30') {
			return _manager.getPlayMovieURL();
		}
		return null;
	};

	return exports;
}(Sizzle));

function onYouTubePlayerAPIReady() {
	var manager = SCE_APP.manager.youtubeManager;
	manager.setDone(true);
	manager.tryCreatePlayers();
}

function onPlayerStateChange(e) {
	var manager = SCE_APP.manager.youtubeManager
		, record;

	record = manager.getMovieInfoAtPlayer(e.target);
	if (e.data === 1 && !record.tracked) {
		record.tracked = true;
		if (s) {
			s.trackPlayVideo('YM:PlayCC:' + record.settings.videoId + ':' + record.title)
		}
	}
}


/**
* informationArea
* @namespace SCE_APP.view
* @class informationArea
*/
SCE_APP.factory.Module.create('view.informationArea', SCE_APP, false, (function() {
	var util = SCE_APP.Utility
		, _NOLABEL_CLASS = '.gen-info-nolabel'
		, _LABEL_CLASS = '.gen-info-label'
		, _HIDDEN_CLASS = '.gen-info-hidden'
		, _BUTTON_CLASS = '.gen-info-more-button'
		, _infoAreas
		, exports = {};
	
	
	function setup() {
		_infoAreas = Sizzle(_NOLABEL_CLASS + ', ' + _LABEL_CLASS);
		if (!_infoAreas || !_infoAreas.length) {
			return false;
		}

		util.each(_infoAreas, function () {
			var moreButton = Sizzle(_BUTTON_CLASS, this);
			showDefault(this);
			if (!moreButton || !moreButton.length) {
				return;
			}
			addButtonListener(this, moreButton);
		});
		return true;
	}

	/**
	* 初期表示の設定
	*/
	function showDefault(wrapper) {
		var num
			, i
			, hiddens = Sizzle(_HIDDEN_CLASS, wrapper)
			, info;

		if (wrapper && wrapper.className && wrapper.className.match('more-')) {
			num = wrapper.className.split('more-')[1];
		}
		for (i = 0; i < num; ++i) {
			info = hiddens[i];
			util.removeClassName(info, _HIDDEN_CLASS.replace('.', ''));
		}
	}

	/**
	* もっとみるボタンのリスナー登録
	*/
	function addButtonListener(area, button) {
		util.addEventListener(button, 'click', util.bind(area, onMoreClicked, [button[0]]));
	}
	
	/**
	* main
	*/
	util.onReady(function() {
		if (!setup()) {
			return;
		}
	});

	/* ------------------------------------------------------------
	* Event
	* ------------------------------------------------------------*/

	function onMoreClicked(event, button) {
		var hiddens = Sizzle(_HIDDEN_CLASS, this);
		util.each(hiddens, function () {
			util.removeClassName(this, _HIDDEN_CLASS.replace('.', ''));
		});
		
		util.removeNode(button);
		util.cancelEvent(event);
	}

	/* ------------------------------------------------------------
	* Exports
	* ------------------------------------------------------------*/
	
	
	return exports;
}()));


/**
* general main
* dependence on Sizzle.js
* @include Sizzle
*/
(function ($, parent) {
	var _util = SCE_APP.Utility
		, _player = SCE_APP.view.moviePlayer;

	_util.onReady(function () {
		/**
		* [GEN HARDWARE SMALL]:: flatHeight
		*/
		_util.setGroupFlatHeight($('.hardware-item-list'), ['li', 'a', '.hardware-item-wrap']);

		_util.setContentsBorder($('.gen-hardware-small li'));
		
		/**
		* [GEN SOFTWARE column1]:: flatHeight
		*/
		_util.setContentsBorder($('.gen-software-column1 .gen-software-inner'));
		
		/**
		* [GEN SOFTWARE column2]:: flatHeight
		*/
		_util.setGroupFlatHeight($('.gen-software-column2'), ['.gen-software-inner', 'a', '.gen-software-column2l-inner']);
		_util.setContentsBorder($('.gen-software-column2 .gen-software-inner, .gen-software-column2 .gen-software-column2l-inner'));

		/**
		* [GEN SOFTWARE SMALL]:: flatHeight
		*/
		SCE_APP.common.setupLineupWrap('.gen-software-small ul');
		_util.addLineupHover($('.gen-software-small li'));

		/**----------------------------------------
		* [GEN MOVIE]:: moviePlayer
		*----------------------------------------*/
		_player.addEventListener(_player.READY, function () {
			/**
			* [GEN MOVIE SET LARGE]:: flatHeight
			*/
			_util.setGroupFlatHeight($('.gen-movie-set-large'), ['.gen-movie-set-large-left, .gen-movie-set-large-right']);

			/**
			* [GEN MOVIE COLUMN2]:: flatHeight
			*/
			_util.setGroupFlatHeight($('.gen-movie-column2'), ['.gen-movie-left, .gen-movie-right']);

			/**
			* [GEN MOVIE SET SMALL]:: flatHeight
			*/
			_util.setGroupFlatHeight($('.gen-movie-set-small'), ['.gen-movie-left, .gen-movie-center, .gen-movie-right']);

			/**
			* [GEN MOVIE SET TINY]:: flatHeight
			*/
			_util.setGroupFlatHeight($('.gen-movie-set-tiny'), ['.gen-movie-left, .gen-movie-right']);

			/**
			* [GEN MOVIE SOFT MEDIUM]:: flatHeight
			*/
			_util.setGroupFlatHeight($('.gen-movie-soft-medium'), ['.gen-movie-left, a', '.gen-movie-left, .gen-software-inner']);
		});

		/**
		* ビデオが実行されない環境の場合は、該当するコンポーネントを削除する
		*/
		_player.addEventListener(_player.DISABLE, function () {
			var nodes = $('.gen-movie-large').concat($('.gen-movie-set-large')).concat($('.gen-movie-column2')).concat($('.gen-movie-set-small')).concat($('.gen-movie-set-tiny')).concat($('.gen-movie-soft-medium'));

			_util.each(nodes, function () {
				_util.removeNode(this);
			});
		});

		_player.init($('.movie-player'));
		
		/**
		* [GEN BANNER, HARDWARE-LEARGE, SOFTWARE-LEARGE]:: Bannerborder
		*/
		_util.setBannerBorder($('.gen-banner-column1 li, .gen-banner-column2 li, .gen-banner-column3 li, .gen-hardware-large .gen-hardware-large-wrapper, .gen-software-large .gen-software-large-inner'));

		adjustImages();

		/**
		* [GEN HARDWARE LARGE]:: flatHeight
		*/
		_util.each($('.gen-hardware-large-wrapper'), function () {
			var a = Sizzle('a', this)[0]
				, inner = Sizzle('.gen-hardware-large-inner', this)[0];

			if (a && inner) {
				a.style.height = (inner.offsetHeight - 11) + 'px';
			}
		});

		/**
		* [GEN SOFTWARE LARGE]:: flatHeight
		*/
		_util.each($('.gen-software-large .gen-software-large-wrapper'), function () {
			var a = Sizzle('a', this)[0]
				, inner = Sizzle('.gen-software-large-inner', this)[0];

			if (a && inner) {
				a.style.height = (inner.offsetHeight - 9) + 'px';
			}
		});


		/**
		* 各種イメージサイズを調整する
		*/
		function adjustImages() {
			var i
				, len
				, thumbs = $('.gen-software-large-thumbs img')
				, larges = $('.gen-hardware-large-inner img');

			for (i = 0, len = thumbs.length; i < len; ++i) {
				adjustImageSize(thumbs[i], 93, 166);
			}

			for (i = 0, len = larges.length; i < len; ++i) {
				adjustImageSize(larges[i], 500, 850);
			}
		}
		
		/**
		* サムネイルサイズの調整
		* @param thumb {Image}
		*/
		function adjustImageSize(thumb, h, w) {
			var tmpH = thumb.height
				, tmpW = thumb.width
				, rate
				, _h = h
				, _w = w;
				
			rate = _h / tmpH;
			thumb.height = _h;
			
			if (Math.ceil(tmpW * rate) >= _w) {
				rate = _w / tmpW;
				thumb.height = Math.round(tmpH * rate);
				thumb.width = _w;
			}
		}
	});
}(Sizzle, window));

